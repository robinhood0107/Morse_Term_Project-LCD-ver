## 1. 전체 구조 개요

- **최상위 모듈**: `Morse_Transceiver_Top`
  - 클럭 분주기 `Clock_Divider`로 0.5초/1초 타이밍 생성
  - `SW[0]`으로 TX / RX 모드 선택
  - `KEY[4:0]`을 TX/RX 모듈에 공통 전달
  - 7-Segment(HEX0~HEX7), LED, Buzzer를 모드에 따라 다르게 사용
- **송신(TX)**: `TX_Module`
  - 문자 선택 / 저장 / 버퍼 삭제 / 송신 제어
  - 저장된 문자들을 **모스 코드 시간 패턴으로 인코딩**해 `tx_buffer`에 쌓고 LED로 출력
- **수신(RX)**: `RX_Module`
  - Dot/Dash 버튼 입력을 모스 코드 트리로 디코딩해 문자로 변환
  - 최근 8문자를 7-Segment에 표시, Buzzer로 입력 피드백 제공

---

## 2. TX_Module 상세 코드 리뷰

### 2.1 인터페이스 및 주요 레지스터

```1:25:TX_Module.v
module TX_Module(
    input wire iCLK,
    input wire iRST,
    input wire iEnable,
    input wire [4:0] iKEY, // KEY[1]: Next, KEY[2]: Save, KEY[0]: Reset A, KEY[3]: Send, KEY[4]: Clear Buffer(#)
    input wire [3:0] iHalfSec,
    output reg [4:0] oCurrentChar, // Index for browsing (0-25)
    output reg [34:0] oDisplayData, // Stored chars (7 chars buffer)
    output wire oLED
);
    reg [139:0] tx_buffer; // Bit stream buffer for transmission (LSB-first)
    reg [7:0]   tx_idx;     // 현재 송신 중인 비트 인덱스 (0 ~ tx_len-1)
    reg [7:0]   tx_len;     // 버퍼에 실제로 채워진 비트 개수
    reg         is_transmitting;

    // Morse 인코딩용 임시 레지스터 (한 문자 기준, 시간 확장된 비트열)
    reg [31:0]  morse_bits; // LSB-first, Dot/Dash 및 간격(0)을 시간 확장해서 저장
    reg [5:0]   morse_len;  // 사용되는 비트 길이 (최대 약 20비트 이내)

    // Dot/Dash 심볼 패턴 (최대 4심볼) 및 길이
    reg [3:0]   sym_bits;   // LSB-first: 각 비트가 Dot(0)/Dash(1) 의미
    reg [2:0]   sym_len;    // 사용 심볼 개수 (0~4)

    integer i;              // 시간 확장용 for-loop 인덱스
    
    // Key Edge Detection
    reg [4:0] key_prev;

    // Output assignment
    // tx_buffer[tx_idx] 비트를 0.5초마다 하나씩 LED로 출력 (LSB부터 순차 전송)
    assign oLED = is_transmitting ? tx_buffer[tx_idx] : 1'b0;
```

- `oCurrentChar`: 현재 선택된 문자 인덱스 (0=A ~ 25=Z), HEX7에 표시됨.
- `oDisplayData`: 최대 7개의 문자 버퍼 (각 5비트 × 7 = 35비트), HEX0~HEX6로 출력.
- `tx_buffer`: LED 송신용 비트 스트림 버퍼.
  - **LSB부터 시간이 흐르는 순서대로** 비트를 저장.
  - Dot/Dash, 부호간/문자간 OFF를 모두 포함한 **시간 확장된 패턴**.
- `tx_len`: `tx_buffer` 안에 실제로 채워진 비트 수.
- `tx_idx`: 현재 송신 중인 비트의 인덱스 (0 ~ tx_len-1).
- `sym_bits`/`sym_len`: “Dot/Dash 심볼 패턴 (최대 4심볼)”을 일단 추상적으로 저장.
- `morse_bits`/`morse_len`: 심볼 패턴을 **Dot=1, Dash=111, 심볼간 0, 문자간 000**으로 시간 확장한 결과.

### 2.2 리셋 및 기본 상태 초기화

```33:41:TX_Module.v
    always @(posedge iCLK or posedge iRST) begin
        if (iRST) begin
            oCurrentChar   <= 0;
            oDisplayData   <= {5'd31, 5'd31, 5'd31, 5'd31, 5'd31, 5'd31, 5'd31}; // Empty (7 chars)
            tx_buffer      <= 0;
            tx_idx         <= 0;
            tx_len         <= 0;
            is_transmitting <= 0;
            key_prev       <= 5'b11111;
```

- 리셋 시:
  - 선택 문자: `A`로 초기화 (`oCurrentChar=0`).
  - 7-Seg 버퍼: 모두 `31`(OFF)로 초기화.
  - `tx_buffer`, `tx_idx`, `tx_len`: 0으로 초기화 → 송신 상태/패턴 모두 클리어.
  - `key_prev=5'b11111`: 모든 키가 “안 눌림(1)” 상태라고 가정 → 엣지 검출 시작점.

### 2.3 버튼 동작별 로직

#### 2.3.1 문자 선택 (KEY[1], KEY[0])

```42:50:TX_Module.v
        end else if (iEnable) begin
            // 1. Character Selection Logic (Browsing)
            if (key_prev[1] && !iKEY[1]) begin // KEY1: Next Char
                if (oCurrentChar == 25) oCurrentChar <= 0;
                else oCurrentChar <= oCurrentChar + 1;
            end 
            else if (key_prev[0] && !iKEY[0]) begin // KEY0: Reset to A
                oCurrentChar <= 0;
            end
```

- `KEY[1]`: falling edge 시 A→B→...→Z→A 순환.
- `KEY[0]`: falling edge 시 무조건 `A`로 리셋.
- 엣지 검출(`key_prev` vs `iKEY`)을 사용하므로, 버튼을 오래 눌러도 한 번만 반응.

#### 2.3.2 문자 저장 + 모스 인코딩 (KEY[2])

```52:76:TX_Module.v
            // 2. Save Logic
            else if (key_prev[2] && !iKEY[2]) begin // KEY2: Save
                // 2-1. 문자 버퍼에 저장 (7-Seg용)
                oDisplayData <= {oDisplayData[29:0], oCurrentChar}; // Shift in (7 chars buffer)

                // 2-2. Morse 인코딩 → Dot/Dash 심볼 패턴 생성 후,
                //      실제 시간 패턴(Dot=1, Dash=111, intra-symbol=0, inter-char=000)으로 확장

                // (1) Dot/Dash 심볼 패턴 정의 (RX의 모스 트리와 동일 의미)
                //     sym_bits: LSB-first, 각 비트가 Dot(0)/Dash(1)
                //     sym_len : 사용 심볼 개수
                sym_bits = 4'd0;
                sym_len  = 3'd0;

                case (oCurrentChar)
                    // A=0, B=1, ..., Z=25
                    5'd0:  begin sym_bits = 4'b0100; sym_len = 3'd2; end // A (.-)    → 0,1
                    5'd1:  begin sym_bits = 4'b0001; sym_len = 3'd4; end // B (-...)  → 1,0,0,0
                    ...
                    5'd25: begin sym_bits = 4'b1100; sym_len = 3'd4; end // Z (--..)  → 1,1,0,0
                    default: begin
                        sym_bits = 4'd0;
                        sym_len  = 3'd0;
                    end
                endcase
```

- `KEY[2]`를 누를 때마다:
  - 현재 선택 문자(`oCurrentChar`)가 7-Seg 버퍼(HEX0~HEX6)에 shift-in.
  - 동일한 문자에 대해 **Dot/Dash 심볼 패턴(sym_bits, sym_len)**을 설정.
- 예시: A(.-)
  - `oCurrentChar=0` → sym_bits=`0100`, sym_len=2
  - 의미: sym_bits[0]=0(Dot), sym_bits[1]=1(Dash)

```108:143:TX_Module.v
                // (2) 심볼 패턴(sym_bits)을 실제 시간 패턴(morse_bits)으로 확장
                //     Dot(0)  = "1"
                //     Dash(1) = "111"
                //     Dot/Dash 사이 = "0"
                //     문자 사이 = "000"
                morse_bits = 32'd0;
                morse_len  = 6'd0;

                for (i = 0; i < 4; i = i + 1) begin
                    if (i < sym_len) begin
                        // Dot / Dash ON 구간
                        if (sym_bits[i] == 1'b0) begin
                            // Dot: 1 tick ON
                            morse_bits[morse_len] = 1'b1;
                            morse_len = morse_len + 1;
                        end else begin
                            // Dash: 3 ticks ON
                            morse_bits[morse_len]     = 1'b1;
                            morse_bits[morse_len + 1] = 1'b1;
                            morse_bits[morse_len + 2] = 1'b1;
                            morse_len = morse_len + 3;
                        end

                        // 심볼 사이 간격: 마지막 심볼이 아니면 0 한 개
                        if (i < (sym_len - 1)) begin
                            morse_bits[morse_len] = 1'b0;
                            morse_len = morse_len + 1;
                        end
                    end
                end

                // 문자 간 간격: 0 세 개 (글자 사이 구분)
                morse_bits[morse_len]     = 1'b0;
                morse_bits[morse_len + 1] = 1'b0;
                morse_bits[morse_len + 2] = 1'b0;
                morse_len = morse_len + 3;
```

- Dot(0) → `1` (1 tick ON)
- Dash(1) → `111` (3 tick ON)
- 심볼 사이(i < sym_len-1) → `0` (0.5초 OFF)
- 문자 끝 → `000` (1.5초 OFF)

예시: A (.-)
- `sym_bits = [0,1]`, `sym_len=2`
- 확장 결과:
  - Dot → `1`
  - intra-gap → `0`
  - Dash → `111`
  - char-gap → `000`
  - 최종 `morse_bits` = `1 0 1 1 1 0 0 0` (LSB부터 시간 순서)

```137:143:TX_Module.v
                // (3) tx_buffer에 시간 확장된 Morse 비트 스트림을 이어붙이기 (LSB-first)
                //     tx_len: 현재까지 채워진 비트 수
                if (morse_len != 0 && (tx_len + morse_len) <= 8'd140) begin
                    // tx_buffer[tx_len + k] = morse_bits[k] (k = 0..morse_len-1)
                    tx_buffer <= tx_buffer | ( ({{108{1'b0}}, morse_bits}) << tx_len );
                    tx_len    <= tx_len + morse_len;
                end
```

- `tx_buffer`의 `tx_len` 위치부터 `morse_len`만큼 새로운 비트 패턴을 추가.
- 기존 내용은 그대로 두고, 뒤에만 이어 붙이는 구조.
- `(tx_len + morse_len) <= 140`으로 오버플로우 방지.

#### 2.3.3 송신 시작 (KEY[3])

```146:153:TX_Module.v
            // 3. Transmit Logic
            else if (key_prev[3] && !iKEY[3]) begin // KEY3: Send
                // 비트 스트림이 하나 이상 있을 때만 송신 시작
                if (tx_len != 0) begin
                    is_transmitting <= 1;
                    tx_idx          <= 0;
                end
            end
```

- `KEY[3]` falling edge 시:
  - `tx_len != 0`이면 송신 시작 → 비트가 없을 때의 무의미한 송신 방지.
  - `tx_idx = 0`부터 시작 → `tx_buffer[0]`부터 시간 순서대로 출력.

#### 2.3.4 버퍼 삭제 (KEY[4])

```154:159:TX_Module.v
            // 4. Buffer Clear (#): 과거 버퍼 전체 삭제 (현재 선택 문자는 그대로)
            else if (key_prev[4] && !iKEY[4]) begin // KEY4: Clear Buffer (#)
                oDisplayData <= {5'd31, 5'd31, 5'd31, 5'd31, 5'd31, 5'd31, 5'd31};
                tx_buffer    <= 0;
                tx_len       <= 0;
            end
```

- 7-Seg 버퍼(HEX0~HEX6)와 LED 송신 버퍼(`tx_buffer`, `tx_len`)를 동시에 리셋.
- 현재 선택 문자(`oCurrentChar`/HEX7)는 유지 → 문장만 지우고 커서는 유지.

### 2.4 송신 타이밍 로직 (0.5초 단위)

```165:180:TX_Module.v
    // Transmission Timing Logic
    reg [3:0] prev_half_sec;
    always @(posedge iCLK) begin
        if (is_transmitting) begin
            if (prev_half_sec != iHalfSec) begin // On 0.5s tick
                // tx_len 비트까지만 송신하고 자동 종료
                if (tx_len == 0 || tx_idx >= (tx_len - 1)) begin
                    is_transmitting <= 0;
                    tx_idx          <= 0;
                end else begin
                    tx_idx <= tx_idx + 1;
                end
            end
        end
        prev_half_sec <= iHalfSec;
    end
```

- `Clock_Divider`에서 오는 `iHalfSec` 값이 바뀔 때마다(=0.5초마다) `tx_idx` 증가.
- `tx_idx`가 `tx_len-1`에 도달하면 송신 종료, 인덱스 0으로 리셋.
- 이때 `oLED = tx_buffer[tx_idx]`이므로:
  - `1`이 연속 1개 → Dot 0.5초 ON
  - `1`이 연속 3개 → Dash 1.5초 ON
  - `0`은 OFF 구간 (부호간 0.5초, 문자간 1.5초)

---

## 3. RX_Module 상세 코드 리뷰 (요약)

```1:22:RX_Module.v
module RX_Module(
    input wire iCLK,
    input wire iRST,
    input wire iEnable,
    input wire [4:0] iKEY, // KEY[1]: Dash, KEY[2]: Dot, KEY[3]: Next/Confirm, KEY[4]: Unused here
    output wire [39:0] oDisplayData, // 8 chars buffer
    output wire oBuzzer
);
    reg [39:0] shift_reg; // Holds 8 decoded characters (5bits * 8)
    
    // Decoding State
    reg [3:0] stack; // Stores dots(0)/dashes(1). LSB first.
    reg [2:0] count; // Number of signals in current char
    reg [4:0] decoded; // [Fix] Declaration moved here from inside always block
    
    // Edge detection for buttons
    reg [4:0] key_prev;
    
    // Buzzer Logic: Beep while key is pressed (Active Low keys assumed)
    assign oBuzzer = iEnable ? (!iKEY[1] || !iKEY[2]) : 1'b0;
    assign oDisplayData = shift_reg;
```

- `KEY[1]`: Dash 입력 → stack에 `1` shift-in.
- `KEY[2]`: Dot 입력 → stack에 `0` shift-in.
- `KEY[3]`: Confirm → `stack`+`count` 조합을 모스 트리로 디코딩 후, 문자 버퍼(8글자)에 shift-in.

```31:41:RX_Module.v
            // KEY[1] (Dash/Long, '1') Falling Edge
            if (key_prev[1] && !iKEY[1]) begin
                stack <= {stack[2:0], 1'b1}; // Shift in 1 (Dash)
                count <= count + 1;
            end
            // KEY[2] (Dot/Short, '0') Falling Edge
            else if (key_prev[2] && !iKEY[2]) begin
                stack <= {stack[2:0], 1'b0}; // Shift in 0 (Dot)
                count <= count + 1;
            end
```

```42:95:RX_Module.v
            // KEY[3] (Confirm/Next) Falling Edge
            else if (key_prev[3] && !iKEY[3]) begin
                // Decode Logic (Full Morse Tree Implementation)
                // A=0, B=1, ..., Z=25
                decoded = 5'd31; // Default Space/Error

                case (count)
                    // Length 1
                    1: case(stack[0])
                        1'b0: decoded = 5'd4;  // E (.)
                        1'b1: decoded = 5'd19; // T (-)
                       endcase
                    ...
                endcase
                
                // Shift into display buffer (Shift Left)
                shift_reg <= {shift_reg[34:0], decoded};
                
                // Reset for next char
                stack <= 0;
                count <= 0;
            end
```

- RX는 **시간 기반이 아니라 버튼 종류(Dot/Dash) + Confirm 버튼**으로만 결정되기 때문에,  
  입력 실수가 적고, TX의 시간 기반 LED 송신과도 논리적으로 잘 대응됩니다.

---

## 4. Morse_Transceiver_Top 및 7-Segment 매핑

```1:10:Morse_Transceiver_Top.v
module Morse_Transceiver_Top(
    input wire iCLK,          // 50MHz Clock
    input wire [4:0] KEY,     // Push Buttons (Active Low usually) - KEY[4]: TX Buffer Clear(#)
    input wire [17:0] SW,     // DIP Switches
    output wire [6:0] SEG,    // 7-Segment segment lines a~g (Active Low, 공통 사용)
    output wire       SEG_DP, // 7-Segment decimal point (h) - 여기서는 항상 OFF
    output wire [7:0] SEG_EN, // 8 Digit 공통 단자 (Active Low: 선택 자리만 0)
    output wire [0:0] LEDG,   // TX Output LED
    output wire oBuzzer       // Piezo Buzzer Output
);
```

- `SW[0]`: 1=TX 모드, 0=RX 모드 (TX/RX 공용).
- `SW[2]`: 전체 리셋 (Clock_Divider, TX, RX, 7-Seg 상태 초기화).
- `KEY[4:0]`: TX/RX 공용 버튼.

```44:53:Morse_Transceiver_Top.v
    TX_Module tx_inst(
        .iCLK(iCLK),
        .iRST(rst),
        .iEnable(is_tx_mode),    // Enable only in TX mode
        .iKEY(KEY),              // KEY inputs for control
        .iHalfSec(half_sec),     // Timing for Morse output
        .oCurrentChar(tx_current_char_idx), // Index of char being selected
        .oDisplayData(tx_display_data),     // Buffer content to display
        .oLED(tx_led_out)        // Morse Code LED Output
    );

    RX_Module rx_inst(
        .iCLK(iCLK),
        .iRST(rst),
        .iEnable(!is_tx_mode),   // Enable only in RX mode
        .iKEY(KEY),              // KEY inputs for Dot/Dash
        .oDisplayData(rx_display_data), // Decoded text
        .oBuzzer(rx_buzzer_out)  // Buzzer sound
    );
```

```66:101:Morse_Transceiver_Top.v
    // 7-Segment Output Logic (8 Digit Array, Scanning 방식)
    // RX mode: rx_display_data[39:0] 전체 8글자 사용
    // TX mode: tx_display_data[34:0] 7글자 + 현재 선택 문자(tx_current_char_idx)를 8번째 자리로 사용
    wire [4:0] char0, char1, char2, char3, char4, char5, char6, char7;
    wire [34:0] buffer_data;

    // 공통 7자리(0~6)는 기존과 동일하게 buffer_data로부터 선택
    assign buffer_data = (is_tx_mode) ? tx_display_data : rx_display_data[34:0];

    assign char0 = buffer_data[4:0];
    assign char1 = buffer_data[9:5];
    assign char2 = buffer_data[14:10];
    assign char3 = buffer_data[19:15];
    assign char4 = buffer_data[24:20];
    assign char5 = buffer_data[29:25];
    assign char6 = buffer_data[34:30];

    // 8번째 자리(7번 자리)는 모드에 따라 다르게 표시
    // TX 모드: 현재 선택 문자 / RX 모드: 수신 버퍼의 최상위 글자
    assign char7 = (is_tx_mode) ? tx_current_char_idx : rx_display_data[39:35];

    // 8 Digit 7-Segment Array 드라이버
    SevenSeg_Array_Driver seg_array_inst (
        .iCLK(iCLK),
        .iRST(rst),
        .char0(char0),
        .char1(char1),
        .char2(char2),
        .char3(char3),
        .char4(char4),
        .char5(char5),
        .char6(char6),
        .char7(char7),
        .oSEG(SEG),
        .oDIGIT(SEG_EN)
    );

    // 소수점은 사용하지 않으므로 항상 OFF (Active Low 기준 1)
    assign SEG_DP = 1'b1;
```

- TX 모드
  - Digit0~6(`SEG_EN[0]~[6]`): 저장된 7글자 버퍼(`tx_display_data` → `char0~6`).
  - Digit7(`SEG_EN[7]`): 현재 선택 중인 글자(`tx_current_char_idx` → `char7`).
- RX 모드
  - Digit0~7: 최근 8글자 (`rx_display_data` → `char0~7`).
- `SevenSeg_Array_Driver` 안에서 공통 세그먼트(`SEG[6:0]`)와 자리 선택(`SEG_EN[7:0]`)을 **스캔 방식**으로 구동하므로, 핀 수는 `SEG[6:0] + SEG_EN[7:0] + SEG_DP`만 사용하면 된다.

---

## 5. 정리

- **TX**: 사용자가 선택/저장한 문장을 **진짜 모스 타이밍(Dot=1, Dash=3, 부호간 0, 문자간 000)**으로 LED에 출력.
- **RX**: 시간 측정 없이 버튼으로 Dot/Dash를 명시적으로 입력하고, Confirm로 문자 경계를 알려주어 **입력 실수가 적은 구조**.
- **상위 모듈**은 7-Seg, LED, Buzzer, 모드를 모두 일관되게 제어하며, README에 기술된 동작과 정확히 일치하도록 구성됨.


